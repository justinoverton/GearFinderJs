<!DOCTYPE html>
<html>
<head>
	<title>Gear Solver</title>
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap-theme.min.css" integrity="sha384-fLW2N01lMqjakBkx3l/M9EahuwpSfeNvV63J5ezn3uZzapT0u7EYsXMjQV+0En5r" crossorigin="anonymous">
	<style>
	.ng-invalid.form-control {
	    border-color: #a94442;
	    -webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.075);
	    box-shadow: inset 0 1px 1px rgba(0,0,0,.075);
	}
	
	polygon, polyline {
		stroke: black;
		fill: transparent;
	}
	
	</style>
</head>
<body>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script type="text/javascript" src="OpenJsCad/csg.js"></script>
<div id="txt">

</div>
<div id="container">

</div>
	
	<script type="text/javascript">

var svg = ['<svg version="1.1" width="100%" height="900" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">'];

// var opts = {
// addendum: 2.5464790894703255,
// angle: 0,
// angleToothToTooth: 51.42857142857143,
// backlash: 0.05,
// centerHoleDiameter: 4,
// circularPitch: 8,
// clearance: 0.05,
// diametralPitch: 0.39269908169872414,
// gearType: 0,
// outerRadius: 11.459155902616466,
// pitchDiameter: 17.82535362629228,
// pitchRadius: 8.91267681314614,
// pressureAngle: 20,
// profileShift: 0,
// shiftedAddendum: 2.5464790894703255,
// show: true,
// toothCount: 7,
// qualitySettings: {stepsPerToothAngle: 3}
// };

// var outerRadius = 11.459155902616466;
// var angleToothToTooth = 51.42857142857143;

var idCounter = 0;
function getId() {
	idCounter++;
	return 'svgElement_' + idCounter;
}

function toothCutter2(opts) {
	//http://lcamtuf.coredump.cx/gcnc/ch6/
	opts = opts || {};
	var toothCount = opts.toothCount || 8;
	var module = opts.module || 12;
	var pressureAngle = opts.pressureAngle || 20;
	var pressureAngleRads  = pressureAngle * Math.PI / 180;
	var profileShift = 0;
	var pitch = module * Math.PI;
	var addendum = 1.0*module;
	var dedendum = 1.25*module;
	var clearance = 0.25*module;
	var refDiameter = toothCount * module;
	var baseDiameter = refDiameter * Math.cos(pressureAngleRads);
	var tipDiameter = refDiameter + (2*module) + (1+profileShift);
	var backlash = 0.05;
	var width = pitch/2;
	var refRadius = refDiameter / 2;
	var sinPressureAngle = Math.sin(pressureAngleRads);
	var cosPressureAngle = Math.cos(pressureAngleRads);
		
	var intersect1 = [-width/2, -refRadius];
	var intersect2 = [width/2, -refRadius];
	
	var cutterDepth = addendum + clearance;
	var cutterOutsideLength = 3 * addendum;
	var dx = backlash / 2 / cosPressureAngle;
	var lowerRightCorner = [width / 2 + dx - cutterDepth * sinPressureAngle, (refRadius + profileShift * addendum - cutterDepth)*-1];
	var upperRightCorner = [width / 2 + dx  + cutterOutsideLength * sinPressureAngle, (refRadius + profileShift * addendum + cutterOutsideLength)*-1];
	var upperLeftCorner = [-upperRightCorner[0], upperRightCorner[1]];
	var lowerLeftCorner = [-lowerRightCorner[0], lowerRightCorner[1]];
	
	var toothpts = [lowerLeftCorner, upperLeftCorner, upperRightCorner, lowerRightCorner];
	
	var toothCutterShape = new CSG.Path2D(toothpts,		/* closed = */ true).innerToCAG();
	
	var angleToothToTooth = 360 / toothCount;
	var angleStepSize = angleToothToTooth / 6; //quality steps per angle

	var toothCutout = new CAG();
	var lowerLeftCorner = new CSG.Vector2D(toothpts[0]);
	
	// To create the tooth profile we move the (virtual) infinite gear and then turn the resulting cutter position back. 
	// For illustration see http://lcamtuf.coredump.cx/gcnc/ch6/, section 'Putting it all together'
	// We continue until the moved tooth cutter's lower left corner is outside of the outer circle of the gear.
	// Going any further will no longer influence the shape of the tooth
	var lowerLeftCornerDistance = 0;
	var stepCounter = 0;
	while (true) {
		var angle = stepCounter * angleStepSize;
		var xTranslation = [angle * Math.PI / 180 * -refRadius, 0];
		var movedLowerLeftCorner = lowerLeftCorner.translate(xTranslation);
		movedLowerLeftCorner = movedLowerLeftCorner.rotateZ(angle);
		
		lowerLeftCornerDistance = movedLowerLeftCorner.length();
		if (movedLowerLeftCorner.length() > tipDiameter/2) {
			// the cutter is now completely outside the gear and no longer influences the shape of the gear tooth
			break;
		}
		// we move in both directions
		var movedToothCutterShape = toothCutterShape.translate(xTranslation);
		var movedToothCutterShape = movedToothCutterShape.rotateZ(angle);
		toothCutout = toothCutout.union(movedToothCutterShape);

		if (xTranslation[0] < 0) {
			//OpenJsCad.log("xTranslation: " + xTranslation);
			movedToothCutterShape = toothCutterShape.translate([-xTranslation[0], xTranslation[1]]);
			movedToothCutterShape = movedToothCutterShape.rotateZ(-angle);
			toothCutout = toothCutout.union(movedToothCutterShape);
		}
		
		stepCounter++;
	}
	
	var outlinePaths = toothCutout.getOutlinePaths();
	var corners = outlinePaths[0].points;
	var cleanedUpCorners = _smoothConcaveCorners(corners);
	
	var points = [];
	cleanedUpCorners.map(function(corner) { points.push([corner.x, corner.y]); });
	var toothCutout = CAG.fromPoints(points).rotateZ(-angleToothToTooth / 2);
	
	var toothSectorPath = new CSG.Path2D([[0,0]], /* closed = */ false);
	var toothSectorArc = CSG.Path2D.arc({
		center: [0, 0],
		radius: -tipDiameter/2,
		startangle: 90,
		endangle: 90 - angleToothToTooth,
		resolution: 30,
	});
	toothSectorPath = toothSectorPath.concat(toothSectorArc);
	toothSectorPath = toothSectorPath.close();
	var toothSector = toothSectorPath.innerToCAG();
	var tooth = toothSector.subtract(toothCutout);
	
	var gearId = getId();
	var ptsId = getId();
	var clipId = getId();
	var sectorClipId = getId();
	
	var sectorSvg = ['<g>'];
	toothSector.getOutlinePaths().map(function(path) {
		sectorSvg.push(path.closed ? '<polygon stroke="black" style="fill: white" points="' : '<polyline stroke="black" fill="none" points="');
		
		for(var pointindex = 0; pointindex < path.points.length; pointindex++) {
			var point = path.points[pointindex];
			sectorSvg.push(point.x.toFixed(7));
			sectorSvg.push(point.y.toFixed(7));
		}
		
		sectorSvg.push('" />');
	});
	sectorSvg.push('</g>');
	
	var toothSvg = [];
	tooth.getOutlinePaths().map(function(path) {
		toothSvg.push(path.closed ? '<polygon stroke="black" points="' : '<polyline stroke="black" fill="none" points="');
		
		for(var pointindex = 0; pointindex < path.points.length; pointindex++) {
			var point = path.points[pointindex];
			toothSvg.push(point.x.toFixed(7));
			toothSvg.push(point.y.toFixed(7));
		}
		
		toothSvg.push('" />');
	});

	var shape = [
		'<defs>', 
		//'<clipPath id="' + clipId + '"><circle cx="0" cy="0" r="', tipDiameter /2 ,'"/></clipPath>',
		'<clipPath id="' + sectorClipId + '">', toothSvg.join(' ') ,'</clipPath>',
		'<g id="' + ptsId + '" clip-path="url(#' + sectorClipId + ')">',
		'<circle cx="0" cy="0" stroke="black" fill="none" r="', tipDiameter /2 ,'"/>',
		'<polygon stroke="black" fill="transparent" points="', points, '" transform="rotate(', -angleToothToTooth/2 ,', 0, 0)" />',
		'</g>',
		'</defs>',
		'<g id="' + gearId + '" transform="translate(', tipDiameter/2 , tipDiameter/2, ')" clip-path="url(#' + clipId + ')" >',
		//'<circle cx="0" cy="0" mask="url(#' + sectorClipId + ')" stroke="black" fill="black" r="', tipDiameter /2 ,'"/>',
		//toothSvg.join(' '),
		//'<g transform="translate(', tipDiameter/2, tipDiameter/2, ')">',
		//'<circle cx="', intersect1[0],'" cy="', intersect1[1],'" r="', 5 , '" stroke-width="1" stroke="green" fill="none" />',
		//'<circle cx="', intersect2[0],'" cy="', intersect1[1],'" r="', 5 , '" stroke-width="1" stroke="green" fill="none" />',
		//'<circle cx="0" cy="0" r="', refRadius , '" stroke-width="1" stroke="black" fill="none" />',
		//'<circle cx="0" cy="0" r="', tipDiameter/2 , '" stroke-width="1" stroke="black" fill="none" />',
		//'<polygon id="' + ptsId + '" points="', toothpts ,'" style="fill:black" stroke="black" stroke-width="1"/>',		
		// '<circle cx="', toothpts[0][0],'" cy="', toothpts[0][1],'" r="', 5 , '" stroke-width="1" stroke="red" fill="none" />',
		// '<circle cx="', toothpts[1][0],'" cy="', toothpts[1][1],'" r="', 5 , '" stroke-width="1" stroke="green" fill="none" />',
		// '<circle cx="', toothpts[2][0],'" cy="', toothpts[2][1],'" r="', 5 , '" stroke-width="1" stroke="blue" fill="none" />',
		// '<circle cx="', toothpts[3][0],'" cy="', toothpts[3][1],'" r="', 5 , '" stroke-width="1" stroke="black" fill="none" />',
	];
	
	for(var i=0; i<toothCount; i++) {
		shape.push('<use xlink:href="#' + ptsId + '" x="0" y="0" transform="rotate(', angleToothToTooth*i ,' 0 0)"  />');
	}
	
	shape.push('</g>');
	return {id: ptsId, shape: shape.join(' ')};
}

function _smoothConcaveCorners(corners) {
	// removes single concave corners located between convex corners
	return _smoothCorners(corners, /* removeSingleConvex= */ false);
}
function _smoothCorners(corners, removeSingleConvex) {
	var isConvex = [];
	var previousCorner = corners[corners.length - 1];
	var currentCorner = corners[0];
	for(var i = 0; i < corners.length; i++) {
		var nextCorner = corners[(i + 1) % corners.length];
		
		var v1 = previousCorner.minus(currentCorner);
		var v2 = nextCorner.minus(currentCorner);
		var crossProduct = v1.cross(v2);
		isConvex.push(crossProduct < 0);
		
		previousCorner = currentCorner;
		currentCorner = nextCorner;
	}
	// we want to remove any concave corners that are located between two convex corners
	var cleanedUpCorners = [];
	var previousIndex = corners.length - 1;
	var currentIndex = 0;
	for(var i = 0; i < corners.length; i++) {
		var corner = corners[currentIndex];
		var nextIndex = (i + 1) % corners.length;
		
		var isSingleConcave = (!isConvex[currentIndex] && isConvex[previousIndex] && isConvex[nextIndex]);
		var isSingleConvex = (isConvex[currentIndex] && !isConvex[previousIndex] && !isConvex[nextIndex]);
		
		previousIndex = currentIndex;
		currentIndex = nextIndex;
		if (removeSingleConvex && isSingleConvex) {
			//OpenJsCad.log("skipping single convex: " + currentIndex);
			continue;
		}
		if (!removeSingleConvex && isSingleConcave) {
			//OpenJsCad.log("skipping single concave: " + currentIndex);
			continue;
		}
		
		cleanedUpCorners.push(corner);
	}				
	
	return cleanedUpCorners;
}

svg.push('<g transform="translate(250 250)">')
svg.push(toothCutter2({
	toothCount: 8,
	module: 12,
	pressureAngle: 20
}).shape);
svg.push('</g>');

svg.push('</svg>');

var raw = svg.join(' ');
$('#container').append($(raw));
$('#txt').text(raw);

		
	</script>
	
</body>
</html>
